# PID

## PID概述

PID调节器各校正环节的作用
1、P比例环节：即时成比例地反应控制系统的偏差信号e(t)，偏差一旦产生，调节器立即产生控制作用以减小偏差。
2、I积分环节：主要用于消除静差，提高系统的无差度。积分作用的强弱取决于积分时间常数TI，TI越大，积分作用越弱，反之则越强。
3、D微分环节：能反应偏差信号的变化趋势(变化速率)，并能在偏差信号的值变得太大之前，在系统中引入一个有效的早期修正信号，从而加快系统的动作速度，减小调节时间。

**但是一般PID闭环控制系统可能不会三个参数同时运用，一般可能PI控制或者PD控制就可以了**

举例：
在二轮平衡车中，对于平衡控制这一闭环PID控制系统，单纯用PD就够了

***详解代码***

首先，定义PID参数，这是我们所需要调节和设定的参数
```c
float Velocity_Kp = 0; //符号为负
float Velocity_Ki = 0;
float Balance_Kp = 0; 
float Balance_Kd = 0;  
```

## 卡尔曼滤波

大部分陀螺仪会有漂移效应，也就是在静止状态时，其陀螺仪反映的值并不是会静止不变的，这个变化的速度可以叫漂移。除了漂移之外，还有其他种种外界干扰因素存在，滤波正是为了解决这一问题。

限幅滤波以及低通滤波等等都是常见的滤波方式，卡尔曼滤波比较复杂。简单来说，在一个控制系统中我们想利用现有的已知状态去预测将要发生的下一状态，比如我们知道现在的速度和加速度可以预测下一时刻的速度，这就是估计；同时，我们测量也会得出一个测量值，但是，由于测量也会有误差，有干扰，眼见不一定为实。那么在估计值和测量值之间是否存在一个中间最优值，最接近于真实状态。这就是滤波，将误差减小到最小。

其实，卡尔曼并不是一定会起到作用，比如硬件精度高，误差确实微乎其微，那么我们也不太需要去滤波，但是有时候卡尔曼滤波却能起到很大的作用去减少真实值的误差。

对于卡尔曼公式的推导，比较复杂，对于线性代数和概率论协方差的知识要求较高，不想讲解。分享几篇我觉得不错的推导讲解：
https://blog.csdn.net/u010720661/article/details/63253509?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163829636816780271990884%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=163829636816780271990884&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-63253509.first_rank_v2_pc_rank_v29&utm_term=%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2&spm=1018.2226.3001.4187

https://www.bilibili.com/video/BV1Rh41117MT?p=5


### 平衡小车中的卡尔曼滤波算法

算法步骤可分为：
1. 预测当前角度
2. 预测协方差矩阵
3. 建立测量方程
4. 计算卡尔曼增益
5. 更新协方差矩阵
6. 计算当前最优化估计值

**1. 预测当前角度**

**2. 预测协方差矩阵**
**3. 建立测量方程**
**4. 计算卡尔曼增益**
**5. 更新协方差矩阵**
**6. 计算当前最优化估计值**

看过网上别人写的关于平衡车的卡尔曼滤波器，有些地方我做了一点改进，更加容易理解。

```c
#include "filter.h"


float K1 =0.02;               //一阶互补滤波器参数


float angle, angle_dot;      //最优估计角度   最优估计角速度	
float Q_angle=0.001;         // 过程噪声的协方差   --角度噪声
float Q_gyro=0.003;          //0.003 过程噪声的协方差 过程噪声的协方差为一个一行两列矩阵   --漂移噪声
float R_angle=0.5;           // 测量噪声的协方差 既测量偏差
float dt=0.005;              //采样时间                 

float Q_bias, Angle_err;     //漂移噪声变量   角度差值=新角度-历史角度最优值  
float K_0, K_1;              //卡尔曼增益

//协方差矩阵初始化时，1和4两个元素分别为角度和漂移的协方差，不能为0，其余两个元素由于角度和漂移是对立的，故相互协方差为零
float PP[2][2] = { { 1, 0 },{ 0, 1 } };  


/**************************************************************************
函数功能：简易卡尔曼滤波
入口参数：加速度、角速度
返回  值：无
**************************************************************************/
void Kalman_Filter(float Accel,float Gyro)		
{

    //状态
//begin0
	angle+=(Gyro - Q_bias) * dt;     //先验估计

	//预测状态协方差矩阵
	PP[0][0] += (Q_angle - PP[0][1] - PP[1][0]) * dt;   // Pk-先验估计误差协方差微分的积分
	PP[0][1] -= PP[1][1] * dt;   // 先验估计误差协方差
	PP[1][0] -= PP[1][1] * dt;
	PP[1][1] += Q_gyro * dt;
//end0


	//观测
//begin1
	Angle_err = Accel - angle;  //观测值与历史最优估计值的差	

   //计算卡尔曼增益
	K_0 = PP[0][0] / R_angle + PP[0][0];           //角度卡尔曼增益
	K_1 = PP[1][0] / R_angle + PP[0][0];           //漂移卡尔曼增益
//end1

    //更新协方差矩阵，为下次更新卡尔曼增益迭代
	PP[0][0] -= K_0 * PP[0][0];		 //后验估计误差协方差
	PP[0][1] -= K_0 * PP[0][1];
	PP[1][0] -= K_1 * PP[0][0];
	PP[1][1] -= K_1 * PP[0][1];

	//计算当前最优化估计值	
	angle	+= K_0 * Angle_err;	 //后验估计
	Q_bias	+= K_1 * Angle_err;	 //后验估计
	angle_dot   = Gyro - Q_bias;	 //输出值(后验估计)的微分=角速度
}
```